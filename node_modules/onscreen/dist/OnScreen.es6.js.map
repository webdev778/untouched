{"version":3,"file":"OnScreen.es6.js","sources":["../lib/methods/attach.js","../lib/helpers/insideViewport.js","../lib/helpers/scrollHandler.js","../lib/methods/debouncedScroll.js","../lib/methods/destroy.js","../lib/methods/off.js","../lib/methods/on.js","../lib/helpers/observeDOM.js","../lib/index.js"],"sourcesContent":["/**\n * Attaches the scroll event handler\n *\n * @return {void}\n */\nfunction attach() {\n    const container = this.options.container;\n\n    if (container instanceof HTMLElement) {\n        const style = window.getComputedStyle(container);\n\n        if (style.position === 'static') {\n            container.style.position = 'relative';\n        }\n    }\n\n    container.addEventListener('scroll', this._scroll);\n    window.addEventListener('resize', this._scroll);\n    this._scroll();\n    this.attached = true;\n}\n\nexport default attach;\n","/**\n * Checks an element's position in respect to the viewport\n * and determines wether it's inside the viewport.\n *\n * @param {node} element The DOM node you want to check\n * @return {boolean} A boolean value that indicates wether is on or off the viewport.\n */\nfunction insideViewport(el, options = { tolerance: 0, container: window }) {\n    if (!el) return false;\n\n    if (typeof el === 'string') {\n        el = document.querySelector(el);\n    }\n    if (typeof options === 'string') {\n        options = { container: document.querySelector(options) };\n    }\n\n    let visible;\n    const elRect = el.getBoundingClientRect();\n\n    if (options.container === window) {\n        visible = (\n            // Check bottom boundary\n            elRect.bottom - options.tolerance > 0 &&\n\n            // Check right boundary\n            elRect.right - options.tolerance > 0 &&\n\n            // Check left boundary\n            elRect.left + options.tolerance < (window.innerWidth ||\n            document.documentElement.clientWidth) &&\n\n            // Check top boundary\n            elRect.top + options.tolerance < (window.innerHeight ||\n            document.documentElement.clientHeight)\n        );\n    } else {\n        const containerRect = options.container.getBoundingClientRect();\n\n        visible = (\n            // // Check bottom boundary\n            (el.offsetTop + el.clientHeight) - options.tolerance >\n            options.container.scrollTop &&\n\n            // Check right boundary\n            (el.offsetLeft + el.clientWidth) - options.tolerance >\n            options.container.scrollLeft &&\n\n            // Check left boundary\n            el.offsetLeft + options.tolerance <\n            containerRect.width + options.container.scrollLeft &&\n\n            // // Check top boundary\n            el.offsetTop + options.tolerance <\n            containerRect.height + options.container.scrollTop\n        );\n    }\n\n    return visible;\n}\n\nexport default insideViewport;\n","import insideViewport from './insideViewport';\n\nexport default function eventHandler(trackedElements = {}, options = { tolerance: 0 }) {\n    const selectors = Object.keys(trackedElements);\n\n    if (!selectors.length) return;\n\n    selectors.forEach((selector) => {\n        trackedElements[selector].nodes.forEach((item) => {\n            if (insideViewport(item.node, options)) {\n                item.wasVisible = item.isVisible;\n                item.isVisible = true;\n            } else {\n                item.wasVisible = item.isVisible;\n                item.isVisible = false;\n            }\n            if (item.isVisible === true && item.wasVisible === false) {\n                if (typeof trackedElements[selector].enter === 'function') {\n                    trackedElements[selector].enter(item.node);\n                }\n            }\n            if (item.isVisible === false && item.wasVisible === true) {\n                if (typeof trackedElements[selector].leave === 'function') {\n                    trackedElements[selector].leave(item.node);\n                }\n            }\n        });\n    });\n}\n","import scrollHandler from '../helpers/scrollHandler';\n\n/**\n * Debounces the scroll event to avoid performance issues\n *\n * @return {void}\n */\nfunction debouncedScroll() {\n    let timeout;\n\n    return () => {\n        clearTimeout(timeout);\n\n        timeout = setTimeout(() => {\n            scrollHandler(this.trackedElements, this.options);\n        }, this.options.throttle);\n    };\n}\n\nexport default debouncedScroll;\n","/**\n * Removes the scroll event handler\n *\n * @return {void}\n */\nfunction destroy() {\n    this.options.container.removeEventListener('scroll', this._scroll);\n    window.removeEventListener('resize', this._scroll);\n    this.attached = false;\n}\n\nexport default destroy;\n","/**\n * Stops tracking elements matching a CSS selector. If a selector has no\n * callbacks it gets removed.\n *\n * @param {string} event The event you want to stop tracking (enter or leave)\n * @param {string} selector The CSS selector you want to stop tracking\n * @return {void}\n */\nfunction off(event, selector) {\n    if (this.trackedElements.hasOwnProperty(selector)) {\n        if (this.trackedElements[selector][event]) {\n            delete this.trackedElements[selector][event];\n        }\n    }\n    if (!this.trackedElements[selector].enter && !this.trackedElements[selector].leave) {\n        delete this.trackedElements[selector];\n    }\n}\n\nexport default off;\n","/**\n * Starts tracking elements matching a CSS selector\n *\n * @param {string} event The event you want to track (enter or leave)\n * @param {string} selector The element you want to track\n * @param {function} callback The callback function to handle the event\n * @return {void}\n */\nfunction on(event, selector, callback) {\n    const allowed = ['enter', 'leave'];\n\n    if (!event) throw new Error('No event given. Choose either enter or leave');\n    if (!selector) throw new Error('No selector to track');\n    if (allowed.indexOf(event) < 0) throw new Error(`${event} event is not supported`);\n\n    if (!this.trackedElements.hasOwnProperty(selector)) {\n        this.trackedElements[selector] = {};\n    }\n\n    this.trackedElements[selector].nodes = [];\n\n    for (let i = 0; i < document.querySelectorAll(selector).length; i++) {\n        const item = {\n            isVisible: false,\n            wasVisible: false,\n            node: document.querySelectorAll(selector)[i]\n        };\n\n        this.trackedElements[selector].nodes.push(item);\n    }\n\n    if (typeof callback === 'function') {\n        this.trackedElements[selector][event] = callback;\n    }\n}\n\nexport default on;\n","/**\n * Observes DOM mutations and runs a callback function when\n * detecting one.\n *\n * @param {node} obj The DOM node you want to observe\n * @param {function} callback The callback function you want to call\n * @return {void}\n */\nfunction observeDOM(obj, callback) {\n    const MutationObserver = window.MutationObserver || window.WebKitMutationObserver;\n    const eventListenerSupported = window.addEventListener;\n\n    if (MutationObserver) {\n        const obs = new MutationObserver((mutations) => {\n            if (mutations[0].addedNodes.length || mutations[0].removedNodes.length) callback();\n        });\n\n        obs.observe(obj, {\n            childList: true,\n            subtree: true\n        });\n    } else if (eventListenerSupported) {\n        obj.addEventListener('DOMNodeInserted', callback, false);\n        obj.addEventListener('DOMNodeRemoved', callback, false);\n    }\n}\n\nexport default observeDOM;\n","// Methods\nimport attach from './methods/attach';\nimport debouncedScroll from './methods/debouncedScroll';\nimport destroy from './methods/destroy';\nimport off from './methods/off';\nimport on from './methods/on';\n\n// Helpers\nimport observeDOM from './helpers/observeDOM';\nimport insideViewport from './helpers/insideViewport';\n\n/**\n * Detects wether DOM nodes enter or leave the viewport\n *\n * @constructor\n * @param {object} options The configuration object\n */\nfunction OnScreen(options = { tolerance: 0, debounce: 100, container: window }) {\n    this.options = {};\n    this.trackedElements = {};\n\n    Object.defineProperties(this.options, {\n        container: {\n            configurable: false,\n            enumerable: false,\n            get() {\n                let container;\n\n                if (typeof options.container === 'string') {\n                    container = document.querySelector(options.container);\n                } else if (options.container instanceof HTMLElement) {\n                    container = options.container;\n                }\n\n                return container || window;\n            },\n            set(value) {\n                options.container = value;\n            }\n        },\n        debounce: {\n            get() {\n                return parseInt(options.debounce, 10) || 100;\n            },\n            set(value) {\n                options.debounce = value;\n            }\n        },\n        tolerance: {\n            get() {\n                return parseInt(options.tolerance, 10) || 0;\n            },\n            set(value) {\n                options.tolerance = value;\n            }\n        }\n    });\n\n    Object.defineProperty(this, '_scroll', {\n        enumerable: false,\n        configurable: false,\n        writable: false,\n        value: this._debouncedScroll.call(this)\n    });\n\n    observeDOM(document.querySelector('body'), () => {\n        Object.keys(this.trackedElements).forEach((element) => {\n            this.on('enter', element);\n            this.on('leave', element);\n        });\n    });\n\n    this.attach();\n}\n\nObject.defineProperties(OnScreen.prototype, {\n    _debouncedScroll: {\n        configurable: false,\n        writable: false,\n        enumerable: false,\n        value: debouncedScroll\n    },\n    attach: {\n        configurable: false,\n        writable: false,\n        enumerable: false,\n        value: attach\n    },\n    destroy: {\n        configurable: false,\n        writable: false,\n        enumerable: false,\n        value: destroy\n    },\n    off: {\n        configurable: false,\n        writable: false,\n        enumerable: false,\n        value: off\n    },\n    on: {\n        configurable: false,\n        writable: false,\n        enumerable: false,\n        value: on\n    }\n});\n\nOnScreen.check = insideViewport;\n\nexport default OnScreen;\n"],"names":[],"mappings":"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"}